<!-- livebook:{"persist_outputs":true} -->

# Visualization

```elixir
Mix.install([
  :phoenix_pubsub,
  {:protean, path: "../protean/"},
  {:protean_kino, path: "./"}
])
```

<!-- livebook:{"output":true} -->

```
==> protean_kino
Compiling 1 file (.ex)
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Section

```elixir
defmodule MyMachine do
  use Protean

  @machine [
    initial: :parent,
    states: [
      compound(:parent,
        initial: :child1,
        on: [
          match(:goto_sibling, target: :sibling)
        ],
        states: [
          atomic(:child1,
            on: [
              match(:goto_child2, target: :child2)
            ]
          ),
          atomic(:child2)
        ]
      ),
      atomic(:sibling)
    ]
  ]
end
```

<!-- livebook:{"output":true} -->

```
{:module, MyMachine, <<70, 79, 82, 49, 0, 0, 32, ...>>, :ok}
```

```elixir
{:ok, machine, id} = Protean.start_machine(MyMachine)
```

<!-- livebook:{"output":true} -->

```
{:ok,
 {:via, Registry,
  {Protean.ProcessManager.Registry, {MyMachine, "54f51cb5-d5ff-4374-a4f6-dc0a8d47ead4"}}},
 "54f51cb5-d5ff-4374-a4f6-dc0a8d47ead4"}
```

```elixir
Protean.Kino.machine(MyMachine.__protean_machine__())
```

<!-- livebook:{"output":true} -->

```
%{
  states: [
    %{
      name: "#",
      statemachine: %{
        states: [
          %{
            name: "#.parent",
            statemachine: %{
              states: [
                %{name: "#.parent.child1", type: "regular"},
                %{name: "#.parent.child2", type: "regular"}
              ],
              transitions: [%{from: "#.parent.child1", to: "#.parent.child2"}]
            },
            type: "regular"
          },
          %{name: "#.sibling", type: "regular"}
        ],
        transitions: [%{from: "#.parent", to: "#.sibling"}]
      },
      type: "regular"
    }
  ],
  transitions: []
}
```
